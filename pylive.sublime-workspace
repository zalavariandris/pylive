{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"link",
				"linkCount"
			],
			[
				"grap",
				"graph_view"
			],
			[
				"lo",
				"logger"
			],
			[
				"res",
				"nodeResult"
			],
			[
				"say_hel",
				"say_hello_script"
			],
			[
				"assertNot",
				"assertIsNotNone"
			],
			[
				"com",
				"isCompiled"
			],
			[
				"evaluate",
				"evaluatedChanged"
			],
			[
				"err",
				"nodeError"
			],
			[
				"is_",
				"is_compiled"
			],
			[
				"node",
				"nodeStatus"
			],
			[
				"nodes",
				"nodeStatus"
			],
			[
				"Mu",
				"MultiDiGraph"
			],
			[
				"Mul",
				"MultiDiGraph"
			],
			[
				"resul",
				"result_view"
			],
			[
				"curr",
				"currentIndex"
			],
			[
				"QItemSele",
				"QItemSelectionModel"
			],
			[
				"QItemS",
				"QItemSelectionModel"
			],
			[
				"la",
				"layoutNodes"
			],
			[
				"graph",
				"graph_view"
			],
			[
				"QLine",
				"QLineF"
			],
			[
				"QRect",
				"QRectF"
			],
			[
				"Qgraphics",
				"QGraphicsItem"
			],
			[
				"setP",
				"setPen"
			],
			[
				"make",
				"makeHorizontalRoundedPath"
			],
			[
				"beginRe",
				"beginResetModel"
			],
			[
				"Parameter",
				"PyParameterItem"
			],
			[
				"conn",
				"connect_nodes"
			],
			[
				"connec",
				"connect_nodes"
			],
			[
				"source_",
				"source_node_index"
			],
			[
				"_d",
				"_drag_controller"
			],
			[
				"_dra",
				"_drag_controller"
			],
			[
				"add",
				"addItem"
			],
			[
				"QGraphc",
				"QGraphicsItem"
			],
			[
				"trace",
				"traceback"
			],
			[
				"_mode",
				"_model_connections"
			],
			[
				"close",
				"closeEvent"
			],
			[
				"setModel",
				"setModelData"
			],
			[
				"source",
				"source_editor"
			],
			[
				"_model",
				"_model_connections"
			],
			[
				"gr",
				"graph_model"
			],
			[
				"_node_",
				"_node_outlets"
			],
			[
				"_edge",
				"_edge_widgets"
			],
			[
				"rowsA",
				"rowsAboutToBeRemoved"
			],
			[
				"edge_",
				"edge_index"
			],
			[
				"_on_node",
				"_on_node_source_changed"
			],
			[
				"NotIm",
				"NotImplementedError"
			],
			[
				"setSele",
				"setSelectionModel"
			],
			[
				"graph_",
				"graph_view"
			],
			[
				"q",
				"qtfactory"
			],
			[
				"gra",
				"graph_view"
			],
			[
				"create",
				"create_new_node"
			],
			[
				"mouse",
				"MouseButtonDblClick"
			],
			[
				"GraphicsSceneD",
				"GraphicsSceneMouseDoubleClick"
			],
			[
				"map",
				"mapFromSource"
			],
			[
				"PyNode",
				"PyNodeProxyModel"
			],
			[
				"target_",
				"target_node_index"
			],
			[
				"sou",
				"nodeSource"
			],
			[
				"setS",
				"setSourceModel"
			],
			[
				"_",
				"_nodes"
			],
			[
				"selected",
				"selected_rows"
			],
			[
				"grou",
				"group_consecutive_numbers"
			],
			[
				"QAbstractI",
				"QAbstractItemModel"
			],
			[
				"Py",
				"PyGraphModel"
			],
			[
				"QAbstractItem",
				"QAbstractItemModel"
			],
			[
				"node_",
				"node_item"
			],
			[
				"current",
				"currentIndex"
			],
			[
				"si",
				"siblingAtColumn"
			],
			[
				"setN",
				"setNodeSelectionModel"
			],
			[
				"StandardE",
				"StandardEdgesModel"
			],
			[
				"PyN",
				"PyNodesModel"
			],
			[
				"property_",
				"property_layout"
			],
			[
				"setNode",
				"setNodeSelectionModel"
			],
			[
				"dis",
				"displayData"
			],
			[
				"sibli",
				"siblingAtColumn"
			],
			[
				"QSelection",
				"QItemSelectionModel"
			],
			[
				"PyNo",
				"PyNodesModel"
			],
			[
				"comp",
				"compiled"
			],
			[
				"e",
				"evaluateNode"
			],
			[
				"cim",
				"compileNode"
			],
			[
				"col",
				"column"
			],
			[
				"sib",
				"siblingAtColumn"
			],
			[
				"out",
				"outlet_widget"
			],
			[
				"_node",
				"_node_inlets"
			],
			[
				"node_w",
				"node_widget"
			],
			[
				"_remove",
				"_removeInlets"
			],
			[
				"inl",
				"inlets"
			],
			[
				"inle",
				"_inlets"
			],
			[
				"_add",
				"_addInlets"
			],
			[
				"target_node",
				"target_node_widget"
			],
			[
				"inserte",
				"rowsInserted"
			],
			[
				"default",
				"default_factory="
			],
			[
				"data",
				"dataChanged"
			],
			[
				"QPe",
				"QPersistentModelIndex"
			],
			[
				"setMax",
				"setMaximumWidth"
			],
			[
				"in",
				"index"
			],
			[
				"edge_in",
				"edge_index"
			],
			[
				"error",
				"error_message"
			],
			[
				"_nodes",
				"_node_selection"
			],
			[
				"_link",
				"_link_graphics_objects"
			],
			[
				"nodeW",
				"nodeWidgets"
			],
			[
				"remove",
				"removeRow"
			],
			[
				"asserNo",
				"assertIsNotNone"
			],
			[
				"inde",
				"indexFromItem"
			],
			[
				"dr",
				"drawComplexControl"
			],
			[
				"setSe",
				"setSelectionModel"
			],
			[
				"MouseButton",
				"MouseButtonRelease"
			],
			[
				"Mouse",
				"MouseButtonPress"
			],
			[
				"QGraphicsMouse",
				"QGraphicsSceneMouseEvent"
			],
			[
				"event",
				"eventFilter"
			],
			[
				"update",
				"updateLinkPosition"
			],
			[
				"pos",
				"scenePos"
			],
			[
				"it",
				"itemAt"
			],
			[
				"Drag",
				"DragResponse"
			],
			[
				"mouseP",
				"GraphicsSceneMousePress"
			],
			[
				"Mult",
				"MultiDiGraph"
			],
			[
				"topol",
				"topological_sort"
			],
			[
				"defa",
				"defaultdict"
			],
			[
				"defaul",
				"defaultlist"
			],
			[
				"Multi",
				"MultiDiGraph"
			],
			[
				"setStyle",
				"setStyleSheet"
			],
			[
				"setPl",
				"setPlainText"
			],
			[
				"setSi",
				"setPreferredSize"
			],
			[
				"QDelegate",
				"QAbstractItemDelegate"
			],
			[
				"GraphicsM",
				"GraphicsSceneMouseDoubleClick"
			],
			[
				"setPs",
				"setPos"
			],
			[
				"curren",
				"current_node_index"
			],
			[
				"setTe",
				"setPlainText"
			]
		]
	},
	"buffers":
	[
		{
			"file": "pylive/VisualCode_v4/graph_editor/graph_editor_view.py",
			"settings":
			{
				"buffer_size": 59856,
				"line_ending": "Windows"
			},
			"undo_stack":
			[
			]
		},
		{
			"contents": "#####################\n# The Network Scene #\n#####################\n\n#\n# A 'View' to represent a network of nodes, connected by inlets and outlets\n#\n\n# In QT ModelView terminology this is a 'View'.\n# It is responsible to present the model.\n# these widgets are responsible to reference the 'graphscene',\n# and the represented nodes, edge and ports.\n\n#\n# TODO:\n# - implement cancelling an ongoing drag event\n#   eg with esc or right click etc.\n\n# - consider allowing any QAbstractItemModel for the _edges_.\n#   Currently only the _.edgeItem_, and _.addEdgeItem_ methods are used internally.\n#   factoring out edgeItem is easy.\n#   to factor out .addEdgeItem, \n#   we need to implement insertRows for the edge model.\n#   insertRows are the default appending method but!\n#   but! it will insert empty rows.\n#   the View must be able to handle incomplete or empty edges.\n\n# - consider using dragEnter instead of dragMove, since that seems to be the\n#   standard event to handle if dragging is acceptable.\n#   this is more obvious on a Mac.\n\n# - consider refactoring drag and drop events since they are pretty repetitive.\n\n# - refactor in v2 the delegate methods.\n#   instead of creating widget within the delegate provide paint, sizeHint, shape\n#   methods to define the node, item, edge visuals.\n#   This will potentially lead to a GraphView that is able to use the builtin StyledItemDelegates\n\n# - consider adding editors for column cell inside the node,\n#   as if a node would be a row in a table, but in a different _view_\n\nimport traceback\nfrom pylive.utils.debug import log_caller\nfrom typing import *\nfrom PySide6.QtGui import *\nfrom PySide6.QtCore import *\nfrom PySide6.QtWidgets import *\n\nfrom bidict import bidict\nfrom collections import defaultdict\n\nfrom pylive.VisualCode_v4.graph_editor.graph_data_roles import GraphDataRole\nfrom pylive.utils.qt import distribute_items_horizontal, signalsBlocked\n\nfrom pylive.VisualCode_v4.graph_editor.standard_graph_delegate import StandardGraphDelegate\nfrom pylive.utils.unique import make_unique_name\n\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\nfrom textwrap import dedent\n\nclass NodeItem:\n    def widget(self):\n        ...\n\n    def ptr(self)->QPersistentModelIndex:\n        ...\n\nclass LinkItem:\n    def widget(self):\n        ...\n\n    def ptr(self)->QPersistentModelIndex:\n        ...\n\nclass InletItem:\n    def widget(self):\n        ...\n\n    def ptr(self)->QPersistentModelIndex:\n        ...\n\nclass OutletItem:\n    def ptr(self)->QPersistentModelIndex:\n        ...\n\n\nclass _GraphEditorView(QGraphicsView):\n    SourceRole = Qt.ItemDataRole.UserRole+1\n    TargetRole = Qt.ItemDataRole.UserRole+2\n    InletsRole = Qt.ItemDataRole.UserRole+3\n    OutletsRole = Qt.ItemDataRole.UserRole+4\n\n    nodesLinked = Signal(QModelIndex, QModelIndex, str, str)\n\n    def __init__(self, parent:QWidget|None=None):\n        super().__init__(parent=parent)\n        self._nodes: QAbstractItemModel | None = None\n        self._edges: QAbstractItemModel | None = None\n        self._delegate: StandardGraphDelegate|None=None\n        self._node_model_connections = []\n        self._edge_model_connections = []\n\n        # store model widget relations\n        self._node_widgets:   bidict[QPersistentModelIndex, QGraphicsItem] = bidict()\n        self._edge_widgets:   bidict[QPersistentModelIndex, QGraphicsItem] = bidict()\n        self._inlet_widgets:  bidict[tuple[QPersistentModelIndex, str], QGraphicsItem] = bidict()\n        self._outlet_widgets: bidict[tuple[QPersistentModelIndex, str], QGraphicsItem] = bidict()\n        self._node_inlets:    dict[QPersistentModelIndex, list[str]] = defaultdict(list)\n        self._node_outlets:   dict[QPersistentModelIndex, list[str]] = defaultdict(list)\n\n        self._node_in_links:defaultdict[QGraphicsItem, list[QGraphicsItem]] = defaultdict(list) # Notes: store attached links, because the underlzing model has to find the relevant edges  and thats is O(n)\n        self._node_out_links:defaultdict[QGraphicsItem, list[QGraphicsItem]] = defaultdict(list) # Notes: store attached links, because the underlzing model has to find the relevant edges  and thats is O(n)\n\n        self.setDragMode(QGraphicsView.DragMode.RubberBandDrag)\n        self.setCacheMode(QGraphicsView.CacheModeFlag.CacheNone)\n        self.setRenderHint(QPainter.RenderHint.Antialiasing, True)\n        self.setRenderHint(QPainter.RenderHint.TextAntialiasing, True)\n        self.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform, True)\n\n        scene = QGraphicsScene()\n        scene.setSceneRect(QRectF(-9999,-9999,9999*2, 9999*2))\n        self.setScene(scene)\n\n        self.setDelegate(StandardGraphDelegate())\n\n    def centerNodes(self):\n        logger.debug(\"centerNodes\")\n        self.centerOn(self.scene().itemsBoundingRect().center())\n\n    def setModel(self, nodes:QAbstractItemModel|None, edges:QAbstractItemModel|None):\n        logger.debug(f\"setModel {nodes} {edges}\")\n        if self._nodes:\n            for signal, slot in self._node_model_connections:\n                signal.disconnect(slot)\n\n        if self._edges:\n            for signal, slot in self._edge_model_connections:\n                signal.disconnect(slot)\n\n        if nodes:\n            self._node_model_connections = [\n                (nodes.modelReset, self._resetWidgets),\n                (nodes.rowsInserted, self._onNodesInserted),\n                (nodes.rowsAboutToBeRemoved, self._onNodesAboutToBeRemoved),\n                (nodes.dataChanged, self._onNodeDataChanged)\n            ]\n            for signal, slot in self._node_model_connections:\n                signal.connect(slot)\n            \n        if edges:\n            self._edge_model_connections = [\n                (edges.modelReset, self._resetWidgets),\n                (edges.rowsInserted, self._onEdgesInserted),\n                (edges.rowsAboutToBeRemoved, self._onEdgesAboutToBeRemoved),\n                (edges.dataChanged, self._onEdgeDataChanged)\n            ]\n            for signal, slot in self._edge_model_connections:\n                signal.connect(slot)\n            \n        self._nodes:QAbstractItemModel|None = nodes\n        self._edges:QAbstractItemModel|None = edges\n\n        # populate initial scene\n        if self._nodes and self._nodes.rowCount()>0:\n            self._onNodesInserted(QModelIndex(), 0, self._nodes.rowCount()-1)\n\n        if self._edges and self._edges.rowCount() > 0:\n            self._onEdgesInserted(QModelIndex(), 0, self._edges.rowCount()-1)\n\n    def model(self)->tuple[QAbstractItemModel|None, QAbstractItemModel|None]:\n        return self._nodes, self._edges\n\n    def setDelegate(self, delegate:StandardGraphDelegate):\n        logger.debug(f\"setDelegate {delegate}\")\n        self._delegate = delegate\n        self._delegate.nodePositionChanged.connect(self._moveAttachedLinks)\n\n    ### Handle Model Signals\n    def _onNodesInserted(self, parent:QModelIndex, first:int, last:int):\n        logger.debug(f\"_onNodesInserted {first}-{last}\")\n        assert self._nodes, \"self._nodes is None\"\n        self._addNodes(range(first, last+1))\n\n    def _onNodesAboutToBeRemoved(self, parent:QModelIndex, first:int, last:int):\n        logger.debug(f\"_onNodesAboutToBeRemoved {first}-{last}\")\n        assert self._nodes, \"self._nodes is None\"\n        self._removeNodes(range(first, last+1))\n\n    def _onNodeDataChanged(self, top_left:QModelIndex, bottom_right:QModelIndex, roles:list[int]=[]):\n        \"\"\"\n        The optional roles argument can be used to specify which data roles have actually been modified.\n        An empty vector in the roles argument means that all roles should be considered modified\"\"\"\n        assert self._nodes, \"self._nodes is None\"\n        logger.debug(f\"_onNodeDataChanged {top_left}-{bottom_right}\")\n        rows = range(top_left.row(), bottom_right.row()+1)\n        self._updateNodes(rows, roles)\n\n    def _onEdgesInserted(self, parent:QModelIndex, first:int, last:int):\n        assert self._edges, \"self._edges is None\"\n        logger.debug(f\"_onEdgesInserted {first}-{last}\")\n        self._addEdges(  [_ for _ in range(first, last+1)]  )\n\n    def _onEdgesAboutToBeRemoved(self, parent:QModelIndex, first:int, last:int):\n        logger.debug(f\"_onEdgesAboutToBeRemoved {first}-{last}\")\n        assert self._edges, \"self._edges is None\"\n        self._removeEdges(range(first, last+1))\n\n    def _onEdgeDataChanged(self, top_left:QModelIndex, bottom_right:QModelIndex, roles:list[int]=[]):\n        \"\"\"\n        The optional roles argument can be used to specify which data roles have actually been modified.\n        An empty vector in the roles argument means that all roles should be considered modified\"\"\"\n        logger.debug(f\"_onEdgeDataChanged {top_left}-{bottom_right} {roles}\")\n        assert self._edges, \"self._edges is None\"\n        self._updateEdges(range(top_left.row(), bottom_right.row()+1))\n\n    ### CRUD WIDGETS\n    def _resetWidgets(self):\n        logger.debug(f\"_resetWidgets\")\n        assert self._nodes, \"self._nodes is None\"\n        ### clear graph\n\n        for inlet_id in self._inlet_widgets.keys():\n            inlet_widget = self._inlet_widgets[inlet_id]\n            self.scene().removeItem(inlet_widget)\n\n        for outlet_id in self._outlet_widgets.keys():\n            outlet_widget = self._outlet_widgets[outlet_id]\n            self.scene().removeItem(outlet_widget)\n\n        for node_index in self._node_widgets.keys():\n            node_widget = self._node_widgets[node_index]\n            self.scene().removeItem(node_widget)\n\n        for edge_index in self._edge_widgets.keys():\n            edge_widget = self._edge_widgets[edge_index]\n            self.scene().removeItem(edge_widget)\n\n        self._node_widgets.clear()\n        self._node_in_links.clear()\n        self._node_out_links.clear()\n\n        ### populate graph with nodes\n        self._addNodes( range(self._nodes.rowCount()) )\n\n        # if nodes were reset, then the links are not linking to a valid widget\n        assert self._edges, \"self._edge is None\"\n        ### clear graph\n        self._edge_widgets.clear()\n\n        ### populate graph with edges\n        if self._edges.rowCount()>0:\n            self._onEdgesInserted(QModelIndex(), 0, self._edges.rowCount()-1)\n\n\n\n    def _addNodes(self, rows:Iterable[int]):\n        logger.debug(f\"_addNodes {rows}\")\n        assert self._nodes\n\n        for row in rows:\n            node_index = self._nodes.index(row, 0)\n            assert node_index.isValid(), \"invalid persistent node?\"\n            node_widget = self._delegate.createNodeWidget(self.scene(), node_index)\n            node_id = QPersistentModelIndex(node_index)\n            self._node_widgets[node_id] = node_widget\n            self._node_out_links[node_widget] = []\n            self._node_in_links[node_widget] = []\n            self._node_inlets[node_id] = list()\n            self._node_outlets[node_id] = list()\n\n            if inlets := self._nodes.data(node_index, GraphDataRole.NodeInletsRole):\n                self._insertInlets(node_index, 0, inlets)\n\n            if outlets := self._nodes.data(node_index, GraphDataRole.NodeOutletsRole):\n                self._insertOutlets(node_index, 0, outlets)\n\n    def _updateNodes(self, rows:Iterable[int], roles:list[int]):\n        logger.debug(f\"_updateNodes rows:{rows}, roles: {roles}\")\n        assert self._nodes, \"self._edges cant be None\"\n        for row in rows:\n            node_index = self._nodes.index(row, 0)\n            node_id = QPersistentModelIndex(node_index)\n            if node_id not in self._node_widgets:\n                print(f\"while updating, node widget does not exist for index: {node_id}\")\n                continue\n\n            node_widget = self.nodeWidget(node_id)\n            self._delegate.updateNodeWidget(node_index, node_widget)\n            self._resetInlets(node_index)\n            self._resetOutlets(node_index)\n\n    def _removeNodes(self, rows:Iterable[int]):\n        logger.debug(f\"_removeNodes rows:{rows}\")\n        assert self._nodes, \"self._noded cant be None\"\n        for row in rows:\n            node_index = self._nodes.index(row, 0)\n            node_id = QPersistentModelIndex(node_index)\n            node_widget = self.nodeWidget(node_index)\n            self.scene().removeItem(node_widget)\n            \n            del self._node_out_links[node_widget]\n            del self._node_in_links[node_widget]\n            del self._node_widgets[node_id]\n\n    def _insertInlets(self, node_index:QModelIndex, start:int, inlets:Iterable[str]):\n        logger.debug(f\"_insertInlets {node_index}, {start} {inlets}\")\n        node_id = QPersistentModelIndex(node_index)\n        node_widget = self.nodeWidget(node_index)\n        for i, inlet in enumerate(inlets, start=start):\n            inlet_widget = self._delegate.createInletWidget(node_widget, node_index, inlet, i)\n            inlet_widget.setParentItem(node_widget)\n            inlet_id = node_id, inlet\n            assert node_id.isValid() and isinstance(inlet, str)\n            self._inlet_widgets[inlet_id] = inlet_widget\n            self._node_inlets[node_id].insert(i, inlet)\n\n        # layout inlets\n        inlet_widgets = [self.inletWidget(node_index, inlet) for inlet in self._node_inlets[node_id]]\n        distribute_items_horizontal(inlet_widgets, node_widget.boundingRect())\n\n        # layout edges\n        self._moveAttachedLinks(node_widget)\n\n    def _removeInlets(self, node_index:QModelIndex, inlets:Iterable[str]):\n        logger.debug(f\"_removeInlets {node_index}, {inlets}\")\n        node_id = QPersistentModelIndex(node_index)\n        node_widget = self.nodeWidget(node_id)\n        for inlet in inlets:\n            inlet_id = QPersistentModelIndex(node_index), inlet\n            inlet_item = self._inlet_widgets[inlet_id]\n            self.scene().removeItem(inlet_item)\n            del self._inlet_widgets[inlet_id]\n            self._node_inlets[node_id].remove(inlet)\n        \n        # layout inlets\n        inlet_widgets = [self.inletWidget(node_index, inlet) for inlet in self._node_inlets[node_id]]\n        distribute_items_horizontal(inlet_widgets, node_widget.boundingRect())\n\n        # layout edges\n        self._moveAttachedLinks(node_widget)\n\n    def _resetInlets(self, node_index:QModelIndex):\n        logger.debug(f\"_resetInlets {node_index}\")\n        assert self._nodes, \"self._edges cant be None\"\n        node_id = QPersistentModelIndex(node_index)\n        self._removeInlets(node_index, self._node_inlets[node_id])\n        inlets = self._nodes.data(node_index, GraphDataRole.NodeInletsRole)\n        self._insertInlets(node_index, 0, inlets)\n\n    def _insertOutlets(self, node_index:QModelIndex, start:int, outlets:Iterable[str]):\n        logger.debug(f\"_insertOutlets {node_index} {start} {outlets}\")\n        node_id = QPersistentModelIndex(node_index)\n        node_widget = self.nodeWidget(node_id)\n        for i, outlet in enumerate(outlets, start=start):\n            outlet_widget = self._delegate.createOutletWidget(node_widget, node_index, outlet, i)\n            outlet_id = QPersistentModelIndex(node_index), outlet\n            self._outlet_widgets[outlet_id] = outlet_widget\n            self._node_outlets[node_id].insert(i, outlet)\n        \n        # layout inlets\n        outlet_widgets = [self.outletWidget(node_index, outlet) for outlet in self._node_outlets[node_id]]\n        for outlet_widget in outlet_widgets:\n            outlet_widget.setY(node_widget.boundingRect().bottom())\n        distribute_items_horizontal(outlet_widgets, node_widget.boundingRect())\n\n        # layout edges\n        self._moveAttachedLinks(node_widget)\n\n    def _removeOutlets(self, node_index:QModelIndex, outlets:Iterable[str]):\n        logger.debug(f\"_removeOutlets {node_index} {outlets}\")\n        node_id = QPersistentModelIndex(node_index)\n        node_widget = self.nodeWidget(node_id)\n        for outlet in outlets:\n            outlet_id = node_id, outlet\n            outlet_item = self._outlet_widgets[outlet_id]\n            self.scene().removeItem(outlet_item)\n            del self._outlet_widgets[outlet_id]\n            self._node_outlets[node_id].remove(outlet)\n        \n        # layout inlets\n        outlet_widgets = [self.outletWidget(node_index, outlet) for outlet in self._node_outlets[node_id]]\n        distribute_items_horizontal(outlet_widgets, node_widget.boundingRect())\n\n        # layout edges\n        self._moveAttachedLinks(node_widget)\n\n    def _resetOutlets(self, node_index:QModelIndex):\n        logger.debug(f\"_resetOutlets\")\n        assert self._nodes, \"self._edges cant be None\"\n        node_id = QPersistentModelIndex(node_index)\n        self._removeOutlets(node_index, self._node_outlets[node_id])\n        outlets = self._nodes.data(node_index, GraphDataRole.NodeOutletsRole)\n        self._insertOutlets(node_index, 0, outlets)\n        \n    def _addEdges(self, rows:Iterable[int]):\n        logger.debug(f\"_addEdges {rows}\")\n        assert self._edges, f\"bad self._edges, got{self._edges}\"\n        assert self._delegate\n        rows = list(rows)\n        assert all(row>=0 for row in rows)\n        for row in sorted(rows):\n            edge_index = self._edges.index(row, 0)\n            assert edge_index.isValid()\n            ### create edge editor\n            edge_id = QPersistentModelIndex(edge_index)\n            edge_widget = self._delegate.createEdgeWidget(edge_index)\n            self._edge_widgets[edge_id] = edge_widget\n            self.scene().addItem( edge_widget )\n\n            #UPDATE LINKS POSITION\n            source_node_index, outlet = self._edges.data(edge_index, GraphDataRole.LinkSourceRole)\n            target_node_index, inlet = self._edges.data(edge_index, GraphDataRole.LinkTargetRole)\n            assert source_node_index.isValid(), f\"got: {source_node_index}\"\n            assert target_node_index.isValid(), f\"got: {target_node_index}\"\n\n            source_node_widget = self.nodeWidget(source_node_index)\n            target_node_widget = self.nodeWidget(target_node_index)\n\n            self._node_out_links[source_node_widget].append(edge_widget)\n            self._node_in_links[target_node_widget].append(edge_widget)\n\n\n            try:\n                source_widget = self.outletWidget(source_node_index, outlet)\n            except KeyError:\n                logger.debug(f\"no outlet widget for {source_node_index}.{outlet}, link to node\")\n                source_widget = target_node_widget\n\n            try:\n                target_widget = self.inletWidget(target_node_index, inlet)\n            except KeyError:\n                logger.debug(f\"no inlet widget for  {target_node_index}.{inlet}, link to node\")\n                target_widget = target_node_widget\n\n\n            self._delegate.updateEdgePosition(edge_widget, source_widget, target_widget)\n\n    def _updateEdges(self, rows:Iterable[int]):\n        assert self._edges\n        assert self._delegate\n        for row in rows:\n            edge_index = self._edges.index(row, 0)\n            editor = self.linkWidget(edge_index)\n            self._delegate.updateEdgeWidget(edge_index, editor)\n\n    def _removeEdges(self, rows:Iterable[int]):\n        assert self._edges\n        rows = set(_ for _ in rows)\n        for row in sorted(rows, reverse=True):\n            edge_index = self._edges.index(row, 0)\n            edge_id = QPersistentModelIndex(edge_index)\n            edge_widget = self.linkWidget(edge_index)\n            assert edge_widget, \"edge_widget is None\"\n            source_node_index, outlet = self._edges.data(edge_index, GraphDataRole.LinkSourceRole)\n            target_node_index, inlet = self._edges.data(edge_index, GraphDataRole.LinkTargetRole)\n            source_node_editor = self.nodeWidget(source_node_index)\n            target_node_editor = self.nodeWidget(target_node_index)\n            self._node_out_links[source_node_editor].remove(edge_widget)\n            self._node_in_links[target_node_editor].remove(edge_widget)\n            self.scene().removeItem(edge_widget)\n            del self._edge_widgets[edge_id]\n        \n    def _moveAttachedLinks(self, node_widget:QGraphicsItem):\n        assert self._edges\n        assert self._delegate\n        from itertools import chain\n\n        for edge_widget in chain(self._node_in_links[node_widget], self._node_out_links[node_widget]):\n            assert edge_widget in self._edge_widgets.values(), f\"got: {edge_widget} not in {[_ for _ in self._edge_widgets.values()]}\"\n            edge_index = self._edge_widgets.inverse[edge_widget]\n\n            source, outlet = self._edges.data(edge_index, GraphDataRole.LinkSourceRole)\n            target, inlet = self._edges.data(edge_index, GraphDataRole.LinkTargetRole)\n\n            try:\n                source_widget = self.outletWidget(source, outlet)\n            except KeyError:\n                logger.debug(\"no outlet widget, link to node\")\n                source_widget = self.nodeWidget(source)\n\n            try:\n                target_widget = self.inletWidget(target, inlet)\n            except KeyError:\n                logger.debug(\"no inlet widget, link to node\")\n                target_widget = self.nodeWidget(target)\n\n            self._delegate.updateEdgePosition(edge_widget, source_widget, target_widget)\n\n    ### Map widgets to model\n    def nodeWidgets(self)->Collection[QGraphicsItem]:\n        return [item for item in self._node_widgets.values()]\n\n    def edgeWidgets(self)->Collection[QGraphicsItem]:\n        return [item for item in self._edge_widgets.values()]\n\n    def nodeWidget(self, node_index: QModelIndex|QPersistentModelIndex) -> QGraphicsItem:\n        assert self._edges, \"self._edges was not defined\"\n        assert node_index.isValid() and node_index.model() == self._nodes, f\"bad node_index, got: {node_index}\"\n        node_id = QPersistentModelIndex(node_index)\n        widget=self._node_widgets[node_id]\n        return widget\n\n    def outletWidget(self, node_index: QModelIndex|QPersistentModelIndex, outlet:str) -> QGraphicsItem:\n        assert self._edges, \"self._edges was not defined\"\n        outlet_id = QPersistentModelIndex(node_index), outlet\n        assert node_index.isValid(), f\"invalid index, got: {node_index}\"\n        widget=self._outlet_widgets[outlet_id]\n        return widget\n\n    def inletWidget(self, node_index: QModelIndex|QPersistentModelIndex, inlet:str) -> QGraphicsItem:\n        assert self._edges\n        assert node_index.isValid()\n        inlet_id = QPersistentModelIndex(node_index), inlet\n        widget=self._inlet_widgets[inlet_id]\n        return widget\n\n    def linkWidget(self, edge_index:QModelIndex|QPersistentModelIndex) -> QGraphicsItem:\n        assert self._edges, \"self._edges was not defined\"\n        if not edge_index.isValid():\n            raise KeyError()\n\n        edge_id = QPersistentModelIndex(edge_index)\n        widget = self._edge_widgets[edge_id]\n        return widget\n\n    ### Widgets At Position\n    def nodeIndexAt(self, pos: QPoint) -> QModelIndex|None:\n        \"\"\"Returns the topmost node at position pos, which is in viewport coordinates.\"\"\"\n        assert self._nodes, \"self._nodes was not defined\"\n        for item in self.items(pos.x()-4,pos.y()-4,8,8):\n            if item in self._node_widgets.values():\n                node_id =  self._node_widgets.inverse[item]\n                return self._nodes.index(node_id.row(), 0)\n\n    def inletIndexAt(self, pos: QPoint)->tuple[QModelIndex, str]|None:\n        \"\"\"Returns the topmost inlet at position pos, which is in viewport coordinates.\"\"\"\n        assert self._nodes, \"self._nodes was not defined\"\n        for item in self.items(pos.x()-4,pos.y()-4,8,8):\n            if item in self._inlet_widgets.values():\n                inlet_id = self._inlet_widgets.inverse[item]\n                node_id, inlet = inlet_id\n                return self._nodes.index(node_id.row(), 0), inlet\n\n    def outletIndexAt(self, pos: QPoint)->tuple[QModelIndex, str]|None:\n        \"\"\"Returns the topmost outlet at position pos, which is in viewport coordinates.\"\"\"\n        assert self._nodes, \"self._nodes was not defined\"\n        for item in self.items(pos.x()-4,pos.y()-4,8,8):\n            if item in self._outlet_widgets.values():\n                outlet_it = self._outlet_widgets.inverse[item]\n                node_id, outlet = outlet_it\n                return self._nodes.index(node_id.row(), 0), outlet\n\n    def edgeIndexAt(self, pos: QPoint) -> QModelIndex|None:\n        \"\"\"Returns the topmost edge at position pos, which is in viewport coordinates.\"\"\"\n        assert self._edges, \"_edges was not defined\"\n        for item in self.items(pos.x()-4,pos.y()-4,8,8):\n            if item in self._edge_widgets.values():\n                edge_id =  self._edge_widgets.inverse[item]\n                return self._edges.index(edge_id.row(), 0)\n\n\nclass _GraphSelectionMixin(_GraphEditorView):\n    ### Node SELECTION\n    def __init__(self, parent: QWidget | None = None):\n        super().__init__(parent)\n        self._node_selection:QItemSelectionModel|None = None\n        \n    def setSelectionModel(self, node_selection:QItemSelectionModel):\n        # assert id(node_selection.model()) != id(self._nodes), f\"trying to set selection model, that works on a different model\\n  {node_selection.model()}\\n  !=\\n  {self._nodes}\"\n\n        if self._node_selection:\n            self._node_selection.selectionChanged.disconnect(self._onNodeSelectionChanged)\n            self.scene().selectionChanged.disconnect(self._syncNodeSelectionModel)\n\n        if node_selection:\n            node_selection.selectionChanged.connect(self._onNodeSelectionChanged)\n            self.scene().selectionChanged.connect(self._syncNodeSelectionModel)\n\n        # set selection model\n        self._node_selection = node_selection\n\n    def _onNodeSelectionChanged(self, selected: QItemSelection, deselected: QItemSelection):\n        \"\"\"on selection model changed\"\"\"\n        assert self._node_selection, \"_node_selection is None\"\n\n        ### update widgets selection\n        selected_node_indexes = set([\n            index.siblingAtColumn(0) \n            for index in self._node_selection.selectedIndexes()\n        ])\n\n        new_node_widgets_selection = set([\n            self.nodeWidget(index) \n            for index in selected_node_indexes\n        ])\n\n        current_node_widgets_selection = set([\n            item for item in self.scene().selectedItems() \n            if item in self._node_widgets.inverse\n        ])\n\n        from pylive.utils.diff import diff_set\n        node_widget_selection_change = diff_set(current_node_widgets_selection, new_node_widgets_selection)\n\n        with signalsBlocked(self.scene()):\n            for node_widget in node_widget_selection_change.added:\n                node_widget.setSelected(True)\n\n            for node_widget in node_widget_selection_change.removed:\n                node_widget.setSelected(False)\n\n    def _syncNodeSelectionModel(self):\n        \"\"\"called when the graphicsScene selection has changed\"\"\"\n        assert self._node_selection, \"_node_selection is None\"\n        assert self._nodes, \"_nodes is None\"\n  \n        selected_items = list(self.scene().selectedItems())\n        selected_node_widgets = list(filter(lambda item: item in self._node_widgets.inverse, selected_items))\n        selected_node_indexes = [self._node_widgets.inverse[node_widget] for node_widget in selected_node_widgets]\n        selected_node_rows = sorted(node_index.row() for node_index in selected_node_indexes)\n\n        from pylive.utils import group_consecutive_numbers\n        selected_row_ranges = list( group_consecutive_numbers(selected_node_rows) )\n\n        new_selection = QItemSelection()\n        for row_range in selected_row_ranges:\n            top_left = self._nodes.index(row_range.start, 0)\n            bottom_right = self._nodes.index(row_range.stop-1, self._nodes.columnCount()-1)\n            selection_range = QItemSelectionRange(top_left, bottom_right)\n            new_selection.append(selection_range)\n\n        if new_selection.count()>0:\n            self._node_selection.setCurrentIndex(new_selection.at(0).topLeft(), QItemSelectionModel.SelectionFlag.Current)\n        else:\n            self._node_selection.setCurrentIndex(QModelIndex(), QItemSelectionModel.SelectionFlag.Clear)\n        self._node_selection.select(new_selection, QItemSelectionModel.SelectionFlag.ClearAndSelect)\n\n\nclass _GraphLayoutMixin(_GraphEditorView):\n    ### Layout\n    def layoutNodes(self, orientation=Qt.Orientation.Vertical, scale=100):\n        logger.debug('layoutNodes')\n        assert self._edges, f\"bad _edges, got: {self._edges}\"\n        assert self._nodes\n        from pylive.utils.graph import hiearchical_layout_with_nx\n        import networkx as nx\n        G = nx.MultiDiGraph()\n        for row in range(self._nodes.rowCount()):\n            persistent_node_index = QPersistentModelIndex( self._nodes.index(row, 0) )\n            G.add_node(persistent_node_index)\n\n        for row in range(self._edges.rowCount()):\n            edge_index = self._edges.index(row, 0)\n            source_node_index, outlet = self._edges.data(edge_index, GraphDataRole.LinkSourceRole)\n            target_node_index, inlet = self._edges.data(edge_index, GraphDataRole.LinkTargetRole)\n\n            G.add_edge(source_node_index, target_node_index)\n        pos:dict[QModelIndex, tuple[float, float]] = hiearchical_layout_with_nx(G, scale=scale)\n        for node_index, (x, y) in pos.items():\n            if node_widget := self.nodeWidget(node_index):\n                match orientation:\n                    case Qt.Orientation.Vertical:\n                        node_widget.setPos(x, y)\n                    case Qt.Orientation.Horizontal:\n                        node_widget.setPos(y, x)\n\n    def _resetWidgets(self):\n        super()._resetWidgets()\n        self.layoutNodes()\n\n\nclass _GraphDragAndDropMixin(_GraphEditorView):\n    def __init__(self, parent: QWidget | None = None):\n        super().__init__(parent)\n        self._draft_link: QGraphicsItem | None = None\n        self._drag_started = True\n        self._drag_valid = False\n        self._current_drag_type = None\n\n    ### Widget Event Handlers\n    def mousePressEvent(self, event: QMouseEvent) -> None:\n        if not self._handleMouseEvent(event):\n            super().mousePressEvent(event)\n\n    def mouseReleaseEvent(self, event: QMouseEvent) -> None:\n        if not self._handleMouseEvent(event):\n            return super().mouseReleaseEvent(event)\n\n    def _handleMouseEvent(self, event: QMouseEvent) -> bool:\n        def event_action(event: QMouseEvent):\n            match event.type():\n                case event.Type.MouseButtonPress:\n                    return \"Press\"\n                case event.Type.MouseButtonRelease:\n                    return \"Release\"\n                case _:\n                    return None\n\n        def item_kind(item):\n            if item in self._outlet_widgets.inverse:\n                return 'outlet', self._outlet_widgets.inverse[item]\n            elif item in self._inlet_widgets.inverse:\n                return 'inlet', self._inlet_widgets.inverse[item]\n            elif item in self._node_widgets.inverse:\n                return 'node', self._node_widgets.inverse[item]\n            elif item in self._edge_widgets.inverse:\n                return 'edge', self._edge_widgets.inverse[item]\n            return None, None\n\n        if action := event_action(event):\n            for item in self.items(event.position().toPoint()):\n                kind, item_id = item_kind(item)\n                if kind:\n                    item_event_handler = getattr(self, f\"{kind}{action}Event\")\n                    return item_event_handler(item_id, event)\n        return False\n\n    def nodePressEvent(self, index: QPersistentModelIndex, event: QMouseEvent) -> bool:\n        return False\n\n    def outletPressEvent(self, outlet_id: tuple[QPersistentModelIndex, str], event: QMouseEvent) -> bool:\n        node_index, outlet_name = outlet_id\n        self.startDragOutlet(node_index.row(), outlet_name)\n        return True\n\n    def inletPressEvent(self, inlet_id: tuple[QPersistentModelIndex, str], event: QMouseEvent) -> bool:\n        node_index, inlet_name = inlet_id\n        self.startDragInlet(node_index.row(), inlet_name)\n        return True\n\n    def edgePressEvent(self, index: QModelIndex | QPersistentModelIndex, event: QMouseEvent) -> bool:\n        assert self._edges\n\n        # source_node_index = index.data(self.SourceRole)\n        # target_node_index = index.data(self.TargetRole)\n        outlet_id = self._edges.data(self._edges.index(index.row(), 0), GraphDataRole.LinkSourceRole)\n        source_node_index, outlet = outlet_id\n        inlet_id = self._edges.data(self._edges.index(index.row(), 0), GraphDataRole.LinkTargetRole)\n        target_node_index, inlet = inlet_id\n\n        outlet_widget = self.outletWidget(source_node_index, outlet)\n        inlet_widget = self.inletWidget(target_node_index, inlet)\n        assert outlet_widget\n        assert inlet_widget\n        mouse_pos = self.mapToScene(event.position().toPoint())\n\n        d1 = (mouse_pos - outlet_widget.pos()).manhattanLength()\n        d2 = (mouse_pos - inlet_widget.pos()).manhattanLength()\n        if d1 > d2:\n            self.startDragEdgeSource(index)\n        else:\n            self.startDragEdgeTarget(index)\n        return True\n\n    def nodeReleaseEvent(self, item: QGraphicsItem, event: QMouseEvent) -> bool:\n        return False\n\n    def outletReleaseEvent(self, item: QGraphicsItem, event: QMouseEvent) -> bool:\n        return False\n\n    def inletReleaseEvent(self, item: QGraphicsItem, event: QMouseEvent) -> bool:\n        return False\n\n    def edgeReleaseEvent(self, item: QGraphicsItem, event: QMouseEvent) -> bool:\n        return False\n\n    ### DRAG links and ports\n    def _createDraftLink(self):\n        assert self._delegate\n        \"\"\"Safely create draft link with state tracking\"\"\"\n        if self._draft_link:\n            # Clean up any existing draft\n            self.scene().removeItem(self._draft_link)\n            self._draft_link = None\n            \n        self._draft_link = self._delegate.createEdgeWidget(QModelIndex())\n        self.scene().addItem(self._draft_link)\n\n    def _cleanupDraftLink(self):\n        \"\"\"Safely cleanup draft link\"\"\"\n        if self._draft_link:\n            self.scene().removeItem(self._draft_link)\n            self._draft_link = None\n\n    def startDragOutlet(self, node_row:int, outlet_name:str):\n        \"\"\"Start outlet drag\"\"\"\n        logger.debug(f\"startDragOutlet\")\n        assert self._edges, \"self._edges was not defined\"\n        \n        # Clean any existing state\n        self._drag_started = False\n        self._drag_valid = False\n        self._current_drag_type = None\n        self._cleanupDraftLink()\n\n        # Setup new drag\n        mime = QMimeData()\n        mime.setData('application/outlet', f\"{node_row}/{outlet_name}\".encode(\"utf-8\"))\n        drag = QDrag(self)\n        drag.setMimeData(mime)\n\n        # Create visual feedback\n        self._createDraftLink()\n        \n        # try\n        action = drag.exec(Qt.DropAction.LinkAction)\n\n        # cleanup\n        self._cleanupDraftLink()\n        logger.debug(f\"startDragOutlet ended: {action}\")\n\n    def startDragInlet(self, node_row:int, inlet_name:str):\n        logger.debug(f\"startDragInlet\")\n        \"\"\" Initiate the drag operation \"\"\"\n        assert self._edges, \"self._edges was not defined\"\n        \n        # Clean any existing state\n        self._drag_started = False\n        self._drag_valid = False\n        self._current_drag_type = None\n        self._cleanupDraftLink()\n\n        # Setup new drag\n        mime = QMimeData()\n        mime.setData('application/inlet', f\"{node_row}/{inlet_name}\".encode(\"utf-8\"))\n        drag = QDrag(self)\n        drag.setMimeData(mime)\n\n        # Create visual feedback\n        self._createDraftLink()\n        \n        # Execute drag\n        # try:\n        action = drag.exec(Qt.DropAction.LinkAction)\n        # finally:\n        # Always cleanup\n        self._cleanupDraftLink()\n        logger.debug(f\"startDragInlet ended: {action}\")\n\n    def startDragEdgeSource(self, edge_index:QModelIndex|QPersistentModelIndex):\n        logger.debug(f\"startDragEdgeSource\")\n        \"\"\" Initiate the drag operation \"\"\"\n        assert self._node_selection, \"self._node_selection was not defined\"\n        assert self._edges, f\"bad self._edges, got{self._edges}\"\n\n        # Clean any existing state\n        self._drag_started = False\n        self._drag_valid = False\n        self._current_drag_type = None\n        self._cleanupDraftLink()\n\n        # Setup new drag\n        mime = QMimeData()\n        mime.setData('application/edge/source', f\"{edge_index.row()}\".encode(\"utf-8\"))\n        drag = QDrag(self)\n        drag.setMimeData(mime)\n        \n        # Execute drag\n        # try:\n        action = drag.exec(Qt.DropAction.LinkAction)\n        # finally:\n        # Always cleanup\n        self._cleanupDraftLink()\n        logger.debug(f\"end startDragEdgeSource\")\n\n    def startDragEdgeTarget(self, edge_index:QModelIndex|QPersistentModelIndex):\n        logger.debug(f\"startDragEdgeTarget\")\n        \"\"\" Initiate the drag operation \"\"\"\n        assert self._node_selection, \"self._node_selection was not defined\"\n        assert self._edges, f\"bad self._edges, got{self._edges}\"\n\n        # Clean any existing state\n        self._drag_started = False\n        self._drag_valid = False\n        self._current_drag_type = None\n        self._cleanupDraftLink()\n\n        # Setup new drag\n        mime = QMimeData()\n        mime.setData('application/edge/target', f\"{edge_index.row()}\".encode(\"utf-8\"))\n        drag = QDrag(self)\n        drag.setMimeData(mime)\n        \n        # Execute drag\n        # try:\n        action = drag.exec(Qt.DropAction.LinkAction)\n        # finally:\n        # Always cleanup\n        self._cleanupDraftLink()\n        logger.debug(f\"end startDragEdgeTarget\")\n\n    def dragEnterEvent(self, event: QDragEnterEvent):\n        logger.debug(f\"dragEnterEvent\")\n        \"\"\"Handle drag enter with state tracking\"\"\"\n        # log_caller()\n        mime = event.mimeData()\n        \n        # Reset state\n        self._drag_started = True\n        self._drag_valid = False\n        self._current_drag_type = None\n        \n        # Check valid mime types\n        if mime.hasFormat('application/outlet'):\n            self._current_drag_type = 'outlet'\n            self._drag_valid = True\n        elif mime.hasFormat('application/inlet'):\n            self._current_drag_type = 'inlet' \n            self._drag_valid = True\n        elif mime.hasFormat('application/edge/source'):\n            self._current_drag_type = 'edge_source'\n            self._drag_valid = True\n        elif mime.hasFormat('application/edge/target'):\n            self._current_drag_type = 'edge_target'\n            self._drag_valid = True\n            \n        if self._drag_valid:\n            event.accept()\n            event.acceptProposedAction()\n        else:\n            event.ignore()\n\n    def dragMoveEvent(self, event: QDragMoveEvent):\n        \"\"\"Handle drag move with state validation\"\"\"\n        logger.debug(f\"dragMoveEvent\")\n        if not self._drag_valid or not self._current_drag_type:\n            event.ignore()\n            return\n            \n        # Use state to determine handler\n        match self._current_drag_type:\n            case 'outlet':\n                self.dragMoveOutletEvent(event)\n                event.accept()\n            case 'inlet':\n                self.dragMoveInletEvent(event)\n                event.accept()\n            case 'edge_source':\n                self.dragMoveEdgeSourceEvent(event)\n                event.accept()\n            case 'edge_target':\n                self.dragMoveEdgeTargetEvent(event)\n                event.accept()\n            case _:\n                print(f\"bad current_drag_type, {self._current_drag_type}\")\n                raise ValueError(f\"bad drag type: {self._current_drag_type}\")\n\n    def dragMoveOutletEvent(self, event:QDragMoveEvent):\n        logger.debug(f\"dragMoveOutletEvent\")\n        assert self._nodes, \"_edges was not defined\"\n        assert self._draft_link, \"self._draft_link was not defined\"\n        assert self._delegate\n        source = event.mimeData().data('application/outlet').toStdString().split(\"/\")\n        source_row, source_outlet = int(source[0]), source[1]\n        source_node_index = self._nodes.index(source_row, 0)\n        source_outlet_widget = self.outletWidget(source_node_index, source_outlet)\n\n        assert isinstance(source_row, int), f\"source_row is not an int!, got: {source_row}\"\n        assert source_node_index.isValid()\n        assert source_outlet_widget\n\n        target_node_index, inlet = self.inletIndexAt(event.position().toPoint()) or (None, None)\n        target_inlet_widget = self.inletWidget(target_node_index, inlet) if (target_node_index and inlet) else None\n\n        if source_outlet_widget and target_inlet_widget:\n            self._delegate.updateEdgePosition(self._draft_link, source_outlet_widget, target_inlet_widget)\n        elif source_outlet_widget:\n            scene_pos = self.mapToScene(event.position().toPoint())\n            self._delegate.updateEdgePosition(self._draft_link, source_outlet_widget, scene_pos)\n\n    def dragMoveInletEvent(self, event:QDragMoveEvent):\n        logger.debug(f\"dragMoveInletEvent\")\n        try:\n            assert self._nodes, \"self._nodes does not exist\"\n            assert self._draft_link, \"self._draft_link does not exist\"\n            assert self._delegate, \"self._delegate does not exist\"\n            source = event.mimeData().data('application/inlet').toStdString().split(\"/\")\n            print(source)\n            source_row, source_outlet = int(source[0]), source[1]\n            source_node_index = self._nodes.index(source_row, 0)\n            source_inlet_widget = self.inletWidget(source_node_index, source_outlet)\n\n            assert isinstance(source_row, int), \"source_row must be an int\"\n            assert source_node_index.isValid(), \"source_node_index is not valid\"\n            assert source_inlet_widget, \"source_inlet_widget is None\"\n\n            target_node_index, outlet = self.outletIndexAt(event.position().toPoint()) or (None, None)\n            target_outlet_widget = self.outletWidget(target_node_index, outlet) if (target_node_index and outlet) else None\n\n            if source_inlet_widget and target_outlet_widget:\n                self._delegate.updateEdgePosition(self._draft_link, target_outlet_widget, source_inlet_widget)\n\n            if source_inlet_widget:\n                scene_pos = self.mapToScene(event.position().toPoint())\n                self._delegate.updateEdgePosition(self._draft_link, scene_pos, source_inlet_widget)\n        except Exception as err:\n            traceback.print_exc()\n\n    def dragMoveEdgeTargetEvent(self, event:QDragMoveEvent):\n        logger.debug(f\"dragMoveEdgeTargetEvent\")\n        assert self._edges\n        assert not self._draft_link\n        assert self._delegate\n        edge_row = int(event.mimeData().data('application/edge/target').toStdString())\n        \n        source_node_index, outlet = self._edges.data(self._edges.index(edge_row, 0), GraphDataRole.LinkSourceRole)\n        source_outlet_widget = self.outletWidget(source_node_index, outlet)\n\n        assert source_node_index.isValid()\n        assert source_outlet_widget\n\n        target_node_index, inlet_name = self.inletIndexAt(event.position().toPoint()) or (None, None)\n        target_inlet_widget = self.inletWidget(target_node_index, inlet_name) if (target_node_index and inlet_name) else None\n\n        if source_outlet_widget and target_inlet_widget:\n            edge_index = self._edges.index(edge_row, 0)\n            edge_widget = self.linkWidget(edge_index)\n            self._delegate.updateEdgePosition(edge_widget, source_outlet_widget, target_inlet_widget)\n\n        elif source_outlet_widget:\n            edge_index = self._edges.index(edge_row, 0)\n            edge_widget = self.linkWidget(edge_index)\n            scene_pos = self.mapToScene(event.position().toPoint())\n            self._delegate.updateEdgePosition(edge_widget, source_outlet_widget, scene_pos)\n\n    def dragMoveEdgeSourceEvent(self, event:QDragMoveEvent):\n        logger.debug(f\"dragMoveEdgeSourceEvent\")\n        assert self._edges\n        assert not self._draft_link\n        assert self._delegate\n\n        edge_row = int(event.mimeData().data('application/edge/source').toStdString())\n\n        target_node_index, inlet = self._edges.data(self._edges.index(edge_row, 0), GraphDataRole.LinkTargetRole)\n\n        target_inlet_widget = self.inletWidget(target_node_index, inlet)\n\n        assert target_node_index.isValid()\n        assert target_inlet_widget\n\n        source_node_index, outlet_name = self.outletIndexAt(event.position().toPoint()) or (None, None)\n        source_outlet_widget = self.outletWidget(source_node_index, outlet_name) if (source_node_index and outlet_name) else None\n\n        if source_outlet_widget and target_inlet_widget:\n            edge_index = self._edges.index(edge_row, 0)\n            edge_widget = self.linkWidget(edge_index)\n            self._delegate.updateEdgePosition(edge_widget, source_outlet_widget, target_inlet_widget)\n\n        elif target_inlet_widget:\n            edge_index = self._edges.index(edge_row, 0)\n            edge_widget = self.linkWidget(edge_index)\n            scene_pos = self.mapToScene(event.position().toPoint())\n            self._delegate.updateEdgePosition(edge_widget, scene_pos, target_inlet_widget)\n\n    def dropEvent(self, event: QDropEvent):\n        logger.debug(f\"dropEvent\")\n        \"\"\"Handle drop with state cleanup\"\"\"\n        if not self._drag_valid or not self._current_drag_type:\n            event.ignore()\n            return\n            \n        # try:\n        match self._current_drag_type:\n            case 'outlet':\n                self.dropOutletEvent(event)\n            case 'inlet':\n                self.dropInletEvent(event)\n            case 'edge_source':\n                self.dropEdgeSourceEvent(event)\n            case 'edge_target':\n                self.dropEdgeTargetEvent(event)\n        # finally:\n        # Always clean up state\n        self._drag_started = False\n        self._drag_valid = False\n        self._current_drag_type = None\n\n    def dropOutletEvent(self, event:QDropEvent):\n        logger.debug(f\"dropOutletEvent\")\n        if event.proposedAction() == Qt.DropAction.LinkAction:\n            assert self._edges, f\"bad self._edges, got{self._edges}\"\n            assert self._nodes, f\"bad self._nodes, got{self._nodes}\"\n            source = event.mimeData().data('application/outlet').toStdString().split(\"/\")\n            source_row, source_outlet = int(source[0]), source[1]\n            source_node_index = self._nodes.index(source_row, 0)\n\n            target_inlet_id = self.inletIndexAt(event.position().toPoint())\n\n\n            if source_node_index and target_inlet_id:\n                assert self._edges, \"self._edges is None\"\n                target_node_index, inlet_name = target_inlet_id\n                self.nodesLinked.emit(\n                    source_node_index, \n                    target_node_index,\n                    \"out\",\n                    inlet_name\n                )\n                event.acceptProposedAction()\n\n    def dropInletEvent(self, event:QDropEvent):\n        logger.debug(f\"dropInletEvent\")\n        if event.proposedAction() == Qt.DropAction.LinkAction:\n            assert self._edges, f\"bad self._edges, got{self._edges}\"\n            assert self._nodes, f\"bad self._nodes, got{self._nodes}\"\n            # parse mime data\n            source_data = event.mimeData().data('application/inlet').toStdString().split(\"/\")\n            source_row, new_source_inlet_name = int(source_data[0]), source_data[1]\n            new_source_node_index = self._nodes.index(source_row, 0)\n\n            new_source_inlet_id = new_source_node_index, new_source_inlet_name\n            target_outlet_id = self.outletIndexAt(event.position().toPoint())\n\n            if new_source_inlet_id and target_outlet_id:\n                # new edge\n                target_node_index, outlet_name = target_outlet_id\n                self.nodesLinked.emit(\n                    target_node_index,\n                    new_source_node_index,\n                    outlet_name,\n                    new_source_inlet_name\n                )\n                event.acceptProposedAction()\n            else:\n                # cancel\n                pass\n\n    def dropEdgeTargetEvent(self, event:QDropEvent):\n        logger.debug(f\"dropEdgeTargetEvent\")\n        assert self._edges, \"bad self._edges\"\n        edge_row = int(event.mimeData().data('application/edge/target').toStdString())\n        edge_source_node_index, outlet = self._edges.data(self._edges.index(edge_row, 0), GraphDataRole.LinkSourceRole)\n        edge_target_node_index, inlet = self._edges.data(self._edges.index(edge_row, 0), GraphDataRole.LinkTargetRole)\n\n        inlet_id_at_mouse = self.inletIndexAt(event.position().toPoint()) or None\n\n        if inlet_id_at_mouse:\n            if inlet_id_at_mouse == (edge_target_node_index, inlet):\n                # do nothing\n                pass\n            else:\n                #remove\n                self._edges.removeRow(edge_row)\n                # create\n                self.nodesLinked.emit(\n                    edge_source_node_index,\n                    inlet_id_at_mouse[0],\n                    outlet,\n                    inlet_id_at_mouse[1]\n                )\n        else:\n            # remove\n            self._edges.removeRow(edge_row)\n\n    def dropEdgeSourceEvent(self, event:QDropEvent):\n        logger.debug(f\"dropEdgeSourceEvent\")\n        assert self._edges, \"bad self._edges\"\n        edge_row = int(event.mimeData().data('application/edge/source').toStdString())\n        edge_source_node_index, outlet = self._edges.data(self._edges.index(edge_row, 0), GraphDataRole.LinkSourceRole)\n        edge_target_node_index, inlet = self._edges.data(self._edges.index(edge_row, 0), GraphDataRole.LinkTargetRole)\n        outlet_at_mouse = self.outletIndexAt(event.position().toPoint()) or None\n\n        if outlet_at_mouse:\n            new_source_node_index, new_outlet = outlet_at_mouse  # Get both new values\n            if outlet_at_mouse == (edge_source_node_index, outlet):\n                # do nothing\n                pass\n            else:\n                #remove\n                self._edges.removeRow(edge_row)\n                # create\n                self.nodesLinked.emit(\n                    new_source_node_index,\n                    edge_target_node_index,\n                    new_outlet,\n                    inlet\n                )\n        else:\n            # remove\n            self._edges.removeRow(edge_row)\n\n    def dragLeaveEvent(self, event: QDragLeaveEvent)->None:\n        logger.debug(f\"dragLeaveEvent\")\n        \"\"\"Handle drag leave with state cleanup\"\"\"\n        if self._draft_link and self._drag_started:\n            # Only clean up if we actually started the drag\n            self._cleanupDraftLink()\n            \n        self._drag_started = False\n        self._drag_valid = False\n        self._current_drag_type = None\n        \n        event.accept()\n\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass InternalDragController:\n    mode: Literal['inlet', 'outlet', 'edge_source', 'edge_target']\n    source_widget: QGraphicsItem\n    draft: QGraphicsItem\n\n\nclass _InternalDragMixin(_GraphEditorView):\n    def __init__(self, parent: QWidget | None = None):\n        super().__init__(parent)\n        self._drag_controller:InternalDragController|None = None\n\n    def mousePressEvent(self, event: QMouseEvent) -> None:\n        assert self._delegate\n        for item in self.items(event.position().toPoint()):\n            if item in self._outlet_widgets.values():\n                draft_link_item = self._delegate.createEdgeWidget(QModelIndex())\n                self._drag_controller = InternalDragController(\n                    mode='outlet',\n                    source_widget= item,\n                    draft=draft_link_item\n                )\n                self.scene().addItem(self._drag_controller.draft)\n                return\n        super().mousePressEvent(event)\n\n    def mouseMoveEvent(self, event: QMouseEvent) -> None:\n        assert self._delegate\n        if self._drag_controller:\n            match self._drag_controller.mode:\n                case 'outlet':\n                    if inlet_id := self.inletIndexAt(event.position().toPoint()):\n                        node_index, inlet = inlet_id\n                        drop_widget = self.inletWidget(node_index, inlet)\n\n                        # self._drag_controller.draft.move(\n                        #     self._drag_controller.source_widget, \n                        #     drop_widget\n                        # )\n                        self._delegate.updateEdgePosition(\n                            self._drag_controller.draft,\n                            self._drag_controller.source_widget, \n                            drop_widget\n                        )\n                        return\n                    else:\n                        # self._drag_controller.draft.move(\n                        #     self._drag_controller.source_widget, \n                        #     self.mapToScene(event.position().toPoint())\n                        # )\n                        self._delegate.updateEdgePosition(\n                            self._drag_controller.draft,\n                            self._drag_controller.source_widget, \n                            self.mapToScene(event.position().toPoint())\n                        )\n                        return\n                case  _:\n                     ...\n\n        else:\n            super().mouseMoveEvent(event)\n\n    def mouseReleaseEvent(self, event: QMouseEvent) -> None:\n        assert self._delegate\n        if self._drag_controller:\n            match self._drag_controller.mode:\n                case 'outlet':\n                    if inlet_id := self.inletIndexAt(event.position().toPoint()):\n                        source_node_index, source_outlet = self._outlet_widgets.inverse[self._drag_controller.source_widget]\n                        drop_node_index, drop_inlet = inlet_id\n                        self.nodesLinked.emit(\n                            source_node_index,\n                            drop_node_index,\n                            source_outlet,\n                            drop_inlet\n                        )\n\n                    else:\n                        #cancel connection\n                        ...\n                case _:\n                    ...\n\n            self.scene().removeItem(self._drag_controller.draft)\n            self._drag_controller = None\n        else:\n            super().mouseReleaseEvent(event)\n\n\n\nclass GraphEditorView(\n    # _GraphDragAndDropMixin,\n    _InternalDragMixin,\n    _GraphSelectionMixin, \n    _GraphLayoutMixin,\n     _GraphEditorView\n    ):\n    ...\n\n\ndef main():\n    app = QApplication()\n\n    # model\n    nodes = QStandardItemModel()\n    nodes.setHeaderData(0, Qt.Orientation.Horizontal, \"name\")\n    \n    edges = QStandardItemModel()\n    node_selection = QItemSelectionModel(nodes)\n    edge_selection = QItemSelectionModel(edges)\n\n    ### views\n    nodelist = QListView()\n    nodelist.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)\n    nodelist.setModel(nodes)\n    nodelist.setSelectionModel(node_selection)\n\n    edgelist = QListView()\n    edgelist.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)\n    edgelist.setModel(edges)\n    edgelist.setSelectionModel(edge_selection)\n\n    graph_view = GraphEditorView()\n    graph_view.setWindowTitle(\"NXNetworkScene\")\n    graph_view.setModel(nodes, edges)\n    graph_view.setSelectionModel(node_selection)\n    graph_view.centerNodes()\n\n    ### ACTIONS\n    window = QWidget()\n    add_node_action = QPushButton(\"add new node\", window)\n    delete_node_action = QPushButton(\"delete node\", window)\n    connect_selected_nodes_action = QPushButton(\"connect selected nodes\", window)\n    remove_edge_action = QPushButton(\"remove edge\", window)\n    layout_action = QPushButton(\"layout nodes\", window)\n\n    buttons_layout = QGridLayout()\n    buttons_layout.addWidget(add_node_action, 0, 0)\n    buttons_layout.addWidget(delete_node_action, 0, 1)\n    buttons_layout.addWidget(connect_selected_nodes_action, 1, 0)\n    buttons_layout.addWidget(remove_edge_action, 1, 1)\n    buttons_layout.addWidget(layout_action, 2, 0, 1, 2)\n\n    grid_layout = QGridLayout()\n    grid_layout.addLayout(buttons_layout, 0, 0)\n    grid_layout.addWidget(nodelist, 1, 0)\n    grid_layout.addWidget(edgelist, 2, 0)\n    grid_layout.addWidget(graph_view, 0, 1, 3, 1)\n\n    window.setLayout(grid_layout)\n    window.show()\n\n    ### commands\n    def create_new_node():\n        item = QStandardItem()\n        node_names = map(lambda row: \n            nodes.data(nodes.index(row, 0), Qt.ItemDataRole.EditRole), \n            range(nodes.rowCount())\n        )\n        node_name = make_unique_name(\"node1\", node_names)\n        item.setData(node_name, Qt.ItemDataRole.DisplayRole) \n        item.setData([\"in1\", \"in2\"], GraphDataRole.NodeInletsRole)\n        item.setData([\"out\"], GraphDataRole.NodeOutletsRole)\n        nodes.insertRow(nodes.rowCount(), item)\n\n    def delete_selected_nodes():\n        indexes:list[QModelIndex] = node_selection.selectedRows(column=0)\n        indexes.sort(key=lambda index:index.row())\n        for index in reversed(indexes):\n            nodes.removeRows(index.row(), 1)\n\n    def create_link(source_node_index:QModelIndex, target_node_index:QModelIndex, outlet:str, inlet:str):\n        # source_node_index = edges.index(source_node_row, 0)\n        # target_node_index = edges.index(target_node_row, 0)\n\n        print(f\"\"\"create_link: {source_node_index} {target_node_index} {outlet} {inlet}\n\n            \"\"\")\n        edge_item = QStandardItem()\n        outlet_id = QPersistentModelIndex(source_node_index), outlet\n        inlet_id = QPersistentModelIndex(target_node_index), inlet\n        edge_item.setData(\"edge\", Qt.ItemDataRole.DisplayRole)\n        edge_item.setData(outlet_id, GraphDataRole.LinkSourceRole)\n        edge_item.setData(inlet_id, GraphDataRole.LinkTargetRole)\n        edges.insertRow(edges.rowCount(), edge_item)\n\n    def connect_selected_nodes():\n        selected_rows = set([index.row() for index in node_selection.selectedIndexes()])\n        if len(selected_rows)<2:\n            return\n\n        target_node_index = node_selection.currentIndex().siblingAtColumn(0)\n        assert target_node_index.isValid(), \"invalid target node\"\n        inlets = nodes.data(target_node_index, GraphDataRole.NodeInletsRole)\n        assert len(inlets)>0\n        for source_node_row in selected_rows:\n            if target_node_index.row() == source_node_row:\n                continue\n\n            source_node_index = nodes.index(source_node_row, 0)\n            assert source_node_index.isValid(), \"invalid source node\"\n            create_link(source_node_index, target_node_index, \"out\", inlets[0])\n\n    def delete_selected_edges():\n        indexes:list[QModelIndex] = edge_selection.selectedRows(column=0)\n        for index in sorted(indexes, key=lambda index:index.row(), reverse=True):\n            edges.removeRows(index.row(), 1)\n\n    ### bind view\n    view_connections = [\n        (add_node_action.pressed, create_new_node),\n        (delete_node_action.pressed, delete_selected_nodes),\n        (connect_selected_nodes_action.pressed, connect_selected_nodes),\n        (remove_edge_action.pressed, delete_selected_edges),\n        (layout_action.pressed, graph_view.layoutNodes),\n        (graph_view.nodesLinked, create_link)\n    ]\n    for signal, slot in view_connections:\n        signal.connect(slot)\n\n\n    app.exec()\n\nif __name__ == \"__main__\":\n    main()\n\n",
			"file": "pylive/VisualCode_v4/graph_editor/graph_editor_view_from_tree_model.py",
			"file_size": 61282,
			"file_write_time": 133848045951078346,
			"settings":
			{
				"buffer_size": 59857,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			},
			"undo_stack":
			[
				[
					5,
					1,
					"paste",
					null,
					"AQAAAAAAAAAAAAAA0OkAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/"
				],
				[
					38,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAADbfAAAAAAAAN98AAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAANt8AAAAAAAA23wAAAAAAAAAAAAAAAPC/"
				]
			]
		}
	],
	"build_system": "Packages/Python/Python.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"remo",
				"Package Control: Remove Package"
			],
			[
				"unfo",
				"Code Folding: Unfold All"
			],
			[
				"fold",
				"Code Folding: Fold All"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"termi",
				"Terminal: Open"
			],
			[
				"termin",
				"Preferences: Terminal Settings"
			],
			[
				"pyri",
				"Preferences: LSP-pyright Settings"
			],
			[
				"debugg",
				"Debugger: Quit"
			],
			[
				"debugger: st",
				"Debugger: Start (no debug)"
			],
			[
				"deb",
				"Debugger: Open"
			],
			[
				"debu",
				"Debugger: Open"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"debug",
				"Package Control: Disable Debug Mode"
			],
			[
				"disa",
				"Package Control: Disable Package"
			],
			[
				"remove p",
				"Package Control: Remove Package"
			],
			[
				"packa",
				"Package Control: List Packages"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"pyrigth",
				"Preferences: LSP-pyright Settings"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"remov",
				"Package Control: Remove Package"
			],
			[
				"terminus",
				"Terminus: Toggle Panel"
			],
			[
				"terminu",
				"Terminus: Close All"
			],
			[
				"instl",
				"Package Control: Install Package"
			],
			[
				"REMOE",
				"Package Control: Remove Package"
			],
			[
				"reinde",
				"Indentation: Reindent Lines"
			],
			[
				"reind",
				"Indentation: Reindent Lines"
			],
			[
				"enable",
				"Package Control: Enable Package"
			],
			[
				"package",
				"Package Control: Disable Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/dev/src/pylive",
		"/C/dev/src/pylive/pylive",
		"/C/dev/src/pylive/pylive/VisualCode_v4",
		"/C/dev/src/pylive/pylive/VisualCode_v4/graph_editor"
	],
	"file_history":
	[
		"/C/dev/src/pylive/pylive/VisualCode_v4/tests/test_py_proxy_models.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/py_data_model.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/tests/math_script.yaml",
		"/C/dev/src/pylive/pylive/VisualCode_v4/tests/say_hello_script.yaml",
		"/C/dev/src/pylive/pylive/VisualCode_v4/tests/test_py_data_model.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/tests/website_builder.yaml",
		"/C/dev/src/pylive/pylive/VisualCode_v4/py_graph_model.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/yaml/scanner.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/yaml/parser.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/graph_editor/graph_editor_view.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/main.py",
		"/C/dev/src/pylive/history.md",
		"/C/dev/src/pylive/ReadMe.md",
		"/C/dev/src/pylive/pylive/VisualCode_v4/graph_editor/standard_link_widget.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/py_nodes_model.py",
		"/C/dev/src/pylive/pylive/utils/geo.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/py_proxy_model.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/graph_editor/standard_graph_delegate.py",
		"/C/dev/src/pylive/TODOs.md",
		"/C/dev/src/pylive/roadmap.md",
		"/C/dev/src/pylive/pylive/utils/qtfactory.py",
		"/C/dev/src/pylive/pylive/utils/evaluate_python.py",
		"/C/dev/src/pylive/pylive/utils/graph.py",
		"/C/dev/src/pylive/pylive/examples/python_function_graph/graph_view.py",
		"/C/dev/src/pylive/pylive/VisualCode_v1/qgraphics_arrow_item.py",
		"/C/dev/src/pylive/pylive/examples/python_function_graph/standard_graph_delegate.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/numpy/typing/tests/data/fail/shape_base.pyi",
		"/C/dev/src/pylive/.venv/Lib/site-packages/fontTools/svgLib/path/shapes.py",
		"/C/dev/src/pylive/pylive/VisualCode_NetworkX/UI/nx_graph_shapes.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/PySide6/QtCore.pyi",
		"/C/dev/src/pylive/pylive/examples/python_function_graph/main.py",
		"/C/dev/src/pylive/pylive/examples/livegraph.py",
		"/C/dev/src/pylive/expreiments/qml/master_details_view_editable_person/main_pyside.py",
		"/C/dev/src/pylive/expreiments/qml/master_details_view/main_pyside.py",
		"/C/dev/src/pylive/pylive/QtScriptEditor/components/textedit_completer.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/networkx/algorithms/dag.py",
		"/C/dev/src/pylive/tests/test_unique.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/graph_editor/graph_data_roles.py",
		"/C/dev/src/pylive/pylive/utils/unique.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/graph_editor/standard_edges_model.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/PyDataModel.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/experimental_py_graph_model.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/node_inspector_widget.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/py_graph_item.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/graph_editor/node_data_roles.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/graph_editor/standard_node_widget.py",
		"/C/Program Files/WindowsApps/PythonSoftwareFoundation.Python.3.13_3.13.752.0_x64__qbz5n2kfra8p0/Lib/dataclasses.py",
		"/C/dev/src/pylive/expreiments/qml/master_details_view/main.qml",
		"/C/dev/src/pylive/expreiments/qml/master_details_view/main_pyqt.py",
		"/C/dev/src/pylive/expreiments/qml/backbone/main.qml",
		"/C/dev/src/pylive/expreiments/qml/backbone/main_pyqt.py",
		"/C/dev/src/pylive/pyproject.toml",
		"/C/dev/src/pylive/expreiments/qml/backbone/main.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/tests/test_graph_editor.py",
		"/C/dev/src/pylive/expreiments/parse_exception_traceback.py",
		"/C/dev/src/pylive/pylive/VisualCode_v4/nodes_model.py",
		"/C/dev/src/pylive/tests/test_bilist.py",
		"/C/dev/src/pylive/pylive/utils/bilist.py",
		"/C/dev/src/pylive/expreiments/qstyle_draw_ptimitive_elements.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/dag_editor_view.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/standard_graph_delegate.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/widgets/standard_node_widget.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/nodes_model.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/edges_model.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/main_py_functions.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/qt_graph_editor_delegate.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/qt_graph_editor_scene.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/fields_model.py",
		"/C/dev/src/pylive/pylive/NXPythonGraphEditor/python_graph_model.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/standard_node_item.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/qt_graph_editor_view.py",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/nx_network_scene.py",
		"/C/dev/src/pylive/pylive.sublime-project",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/nx_graph_model.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/list_tile_delegate.py",
		"/C/Program Files/WindowsApps/PythonSoftwareFoundation.Python.3.12_3.12.2288.0_x64__qbz5n2kfra8p0/Lib/pathlib.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/networkx/classes/reportviews.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/tests/website_builder.yaml",
		"/C/dev/src/pylive/pylive/QtGraphEditor/tests/test_edge_model.py",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/nx_network_item_view.py",
		"/C/dev/src/pylive/pylive/examples/python_function_graph/python_graph_model.py",
		"/C/dev/src/pylive/pylive/QtScriptEditor/script_edit.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/parse_python.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/definitions_model.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/bidict/_base.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/tests/test_py_functions_model.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/py_functions_model.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/tests/test_file_open_save.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/website_builder.yaml",
		"/C/dev/src/pylive/pylive/QtGraphEditor/test_scene_description_serialization.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/inspector_widget_component.py",
		"/C/dev/src/pylive/pylive/utils/__init__.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/main_python functions.py",
		"/C/dev/src/pylive/tests/test_py_functions_model.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/tile_widget.py",
		"/C/dev/src/pylive/expreiments/live_graphics_scene.py",
		"/C/dev/src/pylive/pylive/qt_options_dialog.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/networkx/classes/multidigraph.py",
		"/C/dev/src/pylive/.venv/Lib/site-packages/PySide6/qml/QtQuick/Controls/designer/TextFieldSpecifics.qml",
		"/C/dev/src/pylive/expreiments/PeopleModel.py",
		"/C/dev/src/pylive/pylive/QtLiveApp/document_file_link.py",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/nx_graph_shapes.py",
		"/C/dev/src/pylive/pylive/QtGraphEditor/website_builder.py",
		"/C/dev/src/pylive/pylive/SQLPythonGraphEditor/sql_graph_view.py",
		"/C/dev/src/pylive/pylive/SQLPythonGraphEditor/main.py",
		"/C/dev/src/pylive/pylive/SQLPythonGraphEditor/sql_graph_model.py",
		"/C/dev/src/pylive/tests/test_sql_graph_model.py",
		"/C/dev/src/pylive/expreiments/QSql_table_model_signals.py",
		"/C/dev/src/pylive/pylive/SQLPythonGraphEditor/sql_grph_view.py",
		"/C/dev/src/pylive/pylive/utils/diff.py",
		"/C/dev/src/pylive/expreiments/rx_state_difference/reactivex_and_state_to_change.py",
		"/C/dev/src/pylive/expreiments/reactive/reactive_qt.py",
		"/C/dev/src/reactive-tkinter/main.py",
		"/C/dev/src/pylive/pylive/NXPythonGraphEditor/python_graph_scene_delegate.py",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/main-network_example.py",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/nx_network_scene_outlet_to_inlet.py",
		"/C/dev/src/pylive/pylive/NXPythonGraphEditor/main.py",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/nx_network_scene_delegate.py",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/nx_newtwork_subgraph_view.py",
		"/C/dev/src/pylive/expreiments/edifice_youtube_playlist/youtube_main.py",
		"/C/dev/src/pylive/expreiments/edifice_youtube_playlist/youtube_helpers.py",
		"/C/dev/src/music_library_manager/main.py",
		"/C/dev/src/pylive/pylive/NetworkXGraphEditor/nx_node_inspector_view.py",
		"/C/dev/src/pylive/pylive/NXPythonGraphEditor/python_data_viewer.py",
		"/C/Program Files/WindowsApps/PythonSoftwareFoundation.Python.3.12_3.12.2288.0_x64__qbz5n2kfra8p0/Lib/contextlib.py",
		"/C/dev/src/pylive/pylive/utils/qt.py",
		"/C/dev/src/pylive/pylive/NXPythonGraphEditor/<class 'networkx.utils.decorators.argmap'> compilation 8",
		"/C/dev/src/pylive/.venv/Lib/site-packages/networkx/algorithms/traversal/breadth_first_search.py"
	],
	"find":
	{
		"height": 38.0
	},
	"find_in_files":
	{
		"height": 194.666666667,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"nodes",
			"person_class_script",
			"PyParameterItem",
			"Loader",
			"print",
			"!!!!!!!!!!!!!!!!",
			"debu",
			"compileNode",
			"initalized",
			"status",
			", ",
			"call_function_with_named_args",
			"call_function_with_stored",
			"compile_selected_node",
			"topolo",
			"evaluate",
			"result_view",
			"inspector_view",
			"layout",
			"class QGraphicsArrowItem",
			"arrowitem",
			"class QGraphicsArrowItem",
			"QGraphicsArrowItem",
			"Arrow",
			"class QGraphicsArrowItem",
			"QGraphicsArrowItem",
			"arrow",
			"Rounded",
			"connect_nodes",
			"nodesLinked",
			"connect_nodes",
			"mapFromSource",
			"mapToSource",
			"inspector_view",
			"PyInspe",
			"_addEdges",
			"source",
			"dragMoveInlet",
			"@Slot",
			"linkNodes",
			"nodesLinked",
			"nodesLinkded",
			"nodesLinked",
			"graph_view_connections",
			"for",
			"headers",
			"sourceChanged",
			"_onEdgesAboutToBeRemoved",
			"Widget(",
			"inletIndexAt",
			"Widget(",
			"self._node_widgets[",
			"PyInspectorView",
			"sheets",
			"graph_view",
			"create",
			"node_pr",
			"_inlet_widgets",
			"LinkSourceRole",
			"inlet",
			"nodesLinked",
			"outlets",
			"inlets(",
			"disconnect",
			"result",
			"group",
			"onEdgesInserted",
			"self._edges.",
			"self._edges",
			"_edges",
			"_onNodeDataChanged",
			"dataChanged",
			"EdgesModelProtocol",
			"_nodes",
			"inlets",
			"onNodeDataChanged",
			")\n",
			"Qt",
			"node_inspector",
			"node_inspe",
			"inspector",
			".preview",
			"<=",
			"modelReset",
			"evaluate",
			"print",
			"error",
			"\",\n",
			"_node_inlets",
			"_inlet_widgets",
			"_inlet_widgets.inverse",
			"inverse",
			"_appendOutlets",
			"inver",
			"        # match index.column():\n        #     case 0: #name\n        #         if role == Qt.ItemDataRole.EditRole:\n        #             node_item.name = value\n\n        #             self.dataChanged.emit(\n        #                 index.sibling(index.row(), 0), \n        #                 index.sibling(index.row(), 0)\n        #             )\n\n        #             return True\n        #     case 1: #code\n        #         if role == Qt.ItemDataRole.EditRole:\n        #             node_item.code = value\n        #             self.dataChanged.emit(\n        #                 index.sibling(index.row(), 1), \n        #                 index.sibling(index.row(), 1)\n        #             )\n\n        #             return True\n\n        #     case 2: #func\n        #         if role == Qt.ItemDataRole.EditRole:\n        #             node_item.func = value\n        #             self.dataChanged.emit(\n        #                 index.sibling(index.row(), 2), \n        #                 index.sibling(index.row(), 2)\n        #             )\n\n        #             return True\n\n        #     case 3: #fields\n        #         if role == Qt.ItemDataRole.EditRole:\n        #             node_item.fields = value\n        #             self.dataChanged.emit(\n        #                 index.sibling(index.row(), 3), \n        #                 index.sibling(index.row(), 3)\n        #             )\n        #             return True\n                    \n        # return False",
			"QQuickStyle",
			"evaluate",
			"_nodes",
			"openFile",
			"node_inspector",
			"removeItem",
			"startDragEdge",
			"class StandardEdgeItem",
			"StandardEdgeItem",
			"format_exception",
			"self._node_selection",
			"evaluate",
			"CE_PushButton",
			"self._node_gr",
			"layout(",
			"removeItem",
			"addItem",
			"selectionChanged",
			"print",
			"create_new_node",
			"self._edges",
			"subgraph",
			"topologi",
			"ancestors",
			"self.preview.",
			"evaluate(",
			"NodeItem",
			"UniqueFunctionItem",
			"self.preview",
			"self.pre",
			"self.preview",
			"self.functions",
			"input"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"nodesChanged",
			"EdgeId",
			"LinkEvent",
			"VertexWidget",
			"LinkWidget",
			"ConnectionEvent",
			"interactive_edge_moving_pin",
			"interactive_edge_fixed_pin",
			"interactive_edge_moving_pin",
			"EdgeGraphicsItem",
			"InletGraphicsItem",
			"OutletGraphicsItem",
			"PinGraphicsItem",
			"EdgeRef",
			"OutletRef",
			"InletRef",
			"NodeRef",
			"EdgeRef",
			"OutletRef",
			"InletRef",
			"NodeRef",
			"OutletRef",
			"InletRef",
			"EdgeRef",
			"NodeRef",
			"EdgeDataColumn",
			"OutletDataColumn",
			"InletDataColumn",
			"NodeDataColumn",
			"EdgeView",
			"InletView",
			"OutletView",
			"self._edgeTable",
			"self._outletTable",
			"self._inletTable",
			"self._nodeTable"
		],
		"reverse": false,
		"scrollbar_highlights": true,
		"show_context": true,
		"use_buffer2": true,
		"use_gitignore": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
				{
					"buffer": 0,
					"file": "pylive/VisualCode_v4/graph_editor/graph_editor_view.py",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 59856,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								59856
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								},
								{
									"characters": ".[\"'",
									"selector": "meta.tag, source - comment - string.quoted.double.block - string.quoted.single.block - string.unquoted.heredoc",
									"server": "LSP-pyright"
								}
							],
							"lsp_active": true,
							"lsp_uri": "file:///C:/dev/src/pylive/pylive/VisualCode_v4/graph_editor/graph_editor_view.py",
							"show_definitions": false,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "pylive/VisualCode_v4/graph_editor/graph_editor_view_from_tree_model.py",
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 59857,
						"regions":
						{
						},
						"selection":
						[
							[
								59424,
								59424
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								},
								{
									"characters": ".[\"'",
									"selector": "meta.tag, source - comment - string.quoted.double.block - string.quoted.single.block - string.unquoted.heredoc",
									"server": "LSP-pyright"
								}
							],
							"lsp_active": true,
							"lsp_uri": "file:///C:/dev/src/pylive/pylive/VisualCode_v4/graph_editor/graph_editor_view_from_tree_model.py",
							"show_definitions": false,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 21631.3333333,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
			]
		},
		{
			"sheets":
			[
			]
		}
	],
	"incremental_find":
	{
		"height": 25.3333333333
	},
	"input":
	{
		"height": 79.3333333333
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			],
			[
				2,
				0,
				3,
				1
			]
		],
		"cols":
		[
			0.0,
			0.626046667323,
			0.876873734992,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.Debugger":
	{
		"height": 343.0
	},
	"output.Debugger Console":
	{
		"height": 240.0
	},
	"output.LSP Log Panel":
	{
		"height": 0.0
	},
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.Terminus":
	{
		"height": 412.0
	},
	"output.diagnostics":
	{
		"height": 0.0
	},
	"output.exec":
	{
		"height": 405.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "Python: Run File (CrossPlatform)",
	"project": "pylive.sublime-project",
	"replace":
	{
		"height": 46.6666666667
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"py data mo",
				"pylive\\VisualCode_v4\\py_data_model.py"
			],
			[
				"pynode",
				"pylive\\VisualCode_v4\\py_nodes_model.py"
			],
			[
				"py proxy",
				"pylive\\VisualCode_v4\\py_proxy_model.py"
			],
			[
				"py dta model",
				"pylive\\VisualCode_v4\\py_data_model.py"
			],
			[
				"shap",
				".venv\\Lib\\site-packages\\fontTools\\svgLib\\path\\shapes.py"
			],
			[
				"test py da",
				"pylive\\VisualCode_v4\\tests\\test_py_data_model.py"
			],
			[
				"py node",
				"pylive\\VisualCode_v4\\py_nodes_model.py"
			],
			[
				"py data",
				"pylive\\VisualCode_v4\\py_data_model.py"
			],
			[
				"graph data ro",
				"pylive\\VisualCode_v4\\graph_editor\\graph_data_roles.py"
			],
			[
				"standarde",
				"pylive\\VisualCode_v4\\graph_editor\\standard_edges_model.py"
			],
			[
				"standard_graph_de",
				"pylive\\examples\\python_function_graph\\standard_graph_delegate.py"
			],
			[
				"nodeins",
				"pylive\\VisualCode_v4\\node_inspector_widget.py"
			],
			[
				"py nodes",
				"pylive\\VisualCode_v4\\py_nodes_model.py"
			],
			[
				"graphit",
				"pylive\\VisualCode_v4\\py_graph_item.py"
			],
			[
				"py nod",
				"pylive\\VisualCode_v4\\py_nodes_model.py"
			],
			[
				"graph_i",
				"pylive\\VisualCode_v4\\py_graph_item.py"
			],
			[
				"standar",
				"pylive\\VisualCode_v4\\graph_editor\\standard_edges_model.py"
			],
			[
				"standard",
				"pylive\\VisualCode_v4\\graph_editor\\standard_edges_model.py"
			],
			[
				"standardNode",
				"pylive\\QtGraphEditor\\widgets\\standard_node_widget.py"
			],
			[
				"nodesD",
				"pylive\\QtGraphEditor\\nodes_model.py"
			],
			[
				"node",
				"pylive\\QtGraphEditor\\nodes_model.py"
			],
			[
				"standardN",
				"pylive\\QtGraphEditor\\standard_node_item.py"
			],
			[
				"edgesM",
				"pylive\\QtGraphEditor\\edges_model.py"
			],
			[
				"script",
				"pylive\\QtScriptEditor\\script_edit.py"
			],
			[
				"fields om",
				"pylive\\QtGraphEditor\\fields_model.py"
			],
			[
				"execute",
				"pylive\\utils\\execute_function.py"
			],
			[
				"definition",
				"pylive\\QtGraphEditor\\definitions_model.py"
			],
			[
				"py func",
				"pylive\\QtGraphEditor\\py_functions_model.py"
			],
			[
				"qtf",
				"pylive\\utils\\qtfactory.py"
			],
			[
				"qtfa",
				"pylive\\utils\\qtfactory.py"
			],
			[
				"main py",
				"pylive\\QtGraphEditor\\main_py_functions.py"
			],
			[
				"py function",
				"pylive\\QtGraphEditor\\py_functions_model.py"
			],
			[
				"test py",
				"tests\\test_py_functions_model.py"
			],
			[
				"fieldsmode",
				"pylive\\QtGraphEditor\\fields_model.py"
			],
			[
				"nodesmodel",
				"pylive\\QtGraphEditor\\nodes_model.py"
			],
			[
				"fields mode",
				"pylive\\QtGraphEditor\\fields_model.py"
			],
			[
				"fields mo",
				"pylive\\QtGraphEditor\\fields_model.py"
			],
			[
				"fieldsmo",
				"pylive\\QtGraphEditor\\fields_model.py"
			],
			[
				"graph scene",
				"expreiments\\live_graphics_scene.py"
			],
			[
				"nodesmo",
				"pylive\\QtGraphEditor\\nodes_model.py"
			],
			[
				"qtfac",
				"pylive\\utils\\qtfactory.py"
			],
			[
				"nodes mode",
				"pylive\\QtGraphEditor\\nodes_model.py"
			],
			[
				"definit",
				"pylive\\QtGraphEditor\\definitions_model.py"
			],
			[
				"fields",
				".venv\\Lib\\site-packages\\PySide6\\qml\\QtQuick\\Controls\\designer\\TextFieldSpecifics.qml"
			],
			[
				"main pyth",
				"pylive\\QtGraphEditor\\main_python functions.py"
			],
			[
				"document",
				"pylive\\QtLiveApp\\document_file_link.py"
			],
			[
				"nx python gr",
				"pylive\\NXPythonGraphEditor\\python_graph_model.py"
			],
			[
				"nxgrap",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"nxgraph",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"python ",
				"pylive\\NXPythonGraphEditor\\python_graph_model.py"
			],
			[
				"data view",
				"pylive\\NXPythonGraphEditor\\python_data_viewer.py"
			],
			[
				"python gr",
				"pylive\\NXPythonGraphEditor\\python_graph_model.py"
			],
			[
				"nx node ins",
				"pylive\\NetworkXGraphEditor\\nx_node_inspector_view.py"
			],
			[
				"nx graph",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"nx graph model",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"nx node inspector dele",
				"pylive\\NetworkXGraphEditor\\nx_node_inspector_delegate.py"
			],
			[
				"inspector",
				"pylive\\NetworkXGraphEditor\\nx_node_inspector_view.py"
			],
			[
				"nx netw",
				"pylive\\NetworkXGraphEditor\\nx_network_model.py"
			],
			[
				"nx grap",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"nx network",
				"pylive\\NetworkXGraphEditor\\nx_network_model.py"
			],
			[
				"nx graph mod",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"graph model",
				"pylive\\examples\\python_function_graph\\graph_model.py"
			],
			[
				"nx",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"nx graph mode",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"nxgraph se",
				"pylive\\NetworkXGraphEditor\\nx_graph_selection_model.py"
			],
			[
				"test n",
				"tests\\test_nx_graph_model.py"
			],
			[
				"nx ",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"nxgraphm",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"nxgr",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"shapes",
				"pylive\\NetworkXGraphEditor\\nx_graph_shapes.py"
			],
			[
				"nx network sce",
				"pylive\\NetworkXGraphEditor\\nx_network_scene_outlet-to-inlet.py"
			],
			[
				"geo",
				"pylive\\utils\\geo.py"
			],
			[
				"shape",
				"pylive\\NetworkXGraphEditor\\nx_graph_shapes.py"
			],
			[
				"nx net",
				"pylive\\NetworkXGraphEditor\\nx_network_scene.py"
			],
			[
				"round",
				"script_examples_to_run_live\\rounded_link_item.py"
			],
			[
				"nx graph s",
				"pylive\\NetworkXGraphEditor\\nx_graph_shapes.py"
			],
			[
				"nx graph mo",
				"pylive\\NetworkXGraphEditor\\nx_graph_model.py"
			],
			[
				"icons",
				"expreiments\\display_builtin_icons.py"
			],
			[
				"nxselection",
				"pylive\\QtGraphEditor\\nx_graph_selection_model.py"
			],
			[
				"nx graph graphics",
				"pylive\\QtGraphEditor\\nx_graph_graphics_scene.py"
			],
			[
				"nx graph grap",
				"pylive\\QtGraphEditor\\nx_graph_view.py"
			],
			[
				"nx gr",
				"pylive\\QtGraphEditor\\nx_graph_graphics_scene_with_ports.py"
			],
			[
				"arrowi",
				"pylive\\QtGraphEditor\\NetrowkXGraphEditor\\qgraphics_arrow_item.py"
			],
			[
				"link",
				"pylive\\QtGraphEditor\\NetrowkXGraphEditor\\link_graphics_items.py"
			],
			[
				"DagSc",
				"pylive\\QtGraphEditor\\dag_graph_graphics_scene.py"
			],
			[
				"dag graphics ",
				"pylive\\QtGraphEditor\\dag_graph_graphics_scene.py"
			],
			[
				"main",
				"pylive\\examples\\python_function_graph\\main.py"
			],
			[
				"nxgraphmo",
				"pylive\\QtGraphEditor\\nx_graph_model.py"
			],
			[
				"graphmodel",
				"pylive\\pylive\\QtGraphEditor\\graphmodel_databased.py"
			],
			[
				"graphview",
				"pylive\\pylive\\QtGraphEditor\\graphview_databased.py"
			],
			[
				"build-a",
				"pylive\\expreiments\\built-a-dependency-graph-of-a-python-codebase.py"
			],
			[
				"conne",
				"pylive\\expreiments\\connect_to_ipython.py"
			],
			[
				"number",
				"pylive\\pylive\\QtScriptEditor\\components\\textedit_number_editor.py"
			],
			[
				"lint",
				"pylive\\pylive\\QtScriptEditor\\components\\linter_widget.py"
			],
			[
				"script_",
				"pylive\\pylive\\QtScriptEditor\\script_edit.py"
			],
			[
				"scriptedit",
				"pylive\\pylive\\QtScriptEditor\\script_edit.py"
			],
			[
				"cell_s",
				"pylive\\pylive\\QtScriptEditor\\cell_support.py"
			],
			[
				"live_framewo",
				"pylive\\pylive\\QtLiveFramework\\live_framework_with_exec.py"
			],
			[
				"link file",
				"pylive\\expreiments\\file_textdocument_link.py"
			],
			[
				"jedi",
				"pylive\\pylive\\QtScriptEditor\\components\\jedi_completer.py"
			],
			[
				"with_exec",
				"pylive\\pylive\\QtLiveFramework\\live_framework_with_exec.py"
			],
			[
				"framew",
				"pylive\\pylive\\QtLiveFramework\\live_framework_skeleton.py"
			],
			[
				"moderngl",
				"pylive\\pylive\\render_engine\\glwidget_with_moderngl.py"
			],
			[
				"modenr",
				"pylive\\expreiments\\3d_rendering\\pygame_moderngl_boilerplate.py"
			],
			[
				"regl",
				"pylive\\pylive\\render_engine\\regl\\regl.py"
			],
			[
				"logwind",
				"pylive\\pylive\\logwindow.py"
			],
			[
				"resou",
				"pylive\\pylive\\render_engine\\resource_manager.py"
			],
			[
				"render",
				"pylive\\pylive\\render_engine\\render_layers.py"
			],
			[
				"resource",
				"pylive\\pylive\\render_engine\\resource_manager.py"
			],
			[
				"modern",
				"pylive\\pylive\\render_engine\\glwidget_with_moderngl.py"
			],
			[
				"unifie",
				"pylive\\expreiments\\unified_titlebar.py"
			],
			[
				"camer",
				"pylive\\pylive\\render_engine\\camera.py"
			],
			[
				"linter",
				"pylive\\pylive\\QtScriptEditor\\components\\linter_widget.py"
			],
			[
				"Script",
				"pylive\\pylive\\QtScriptEditor\\script_edit.py"
			],
			[
				"camera",
				"pylive\\pylive\\render_engine\\camera.py"
			],
			[
				"orbit",
				"pylive\\pylive\\render_engine\\orbit_control.py"
			],
			[
				"renderl",
				"pylive\\pylive\\render_engine\\render_layers.py"
			],
			[
				"live",
				"pylive\\pylive\\examples\\livescript.py"
			],
			[
				"orbitcon",
				"pylive\\expreiments\\3d_rendering\\orbit_control.py"
			],
			[
				"number editor",
				"pylive\\pylive\\QtScriptEditor\\components\\textedit_number_editor.py"
			],
			[
				"whitespace",
				"pylive\\pylive\\QtScriptEditor\\components\\WhitespaceHighlighter.py"
			],
			[
				"pygme",
				"pylive\\pylive\\QtScriptEditor\\components\\pygments_syntax_highlighter.py"
			],
			[
				"highlighte",
				"pylive\\pylive\\QtScriptEditor\\highlighters.py"
			],
			[
				"textedito",
				"pylive\\pylive\\QtScriptEditor\\components\\textedit_completer.py"
			],
			[
				"keywo",
				"pylive\\pylive\\QtScriptEditor\\components\\KeywordsCompleter.py"
			],
			[
				"scrip",
				"pylive\\pylive\\QtScriptEditor\\ScriptEdit.py"
			],
			[
				"logw",
				"pylive\\pylive\\logwindow.py"
			],
			[
				"capture",
				"pylive\\.venv\\Lib\\site-packages\\IPython\\utils\\capture.py"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 59.3333333333,
		"last_filter": "setSelec",
		"selected_items":
		[
			[
				"setSelec",
				"setSelectionModel"
			],
			[
				"setSource",
				"setSourceOutlet"
			],
			[
				"circle",
				"CircleWidget"
			]
		],
		"width": 592.0
	},
	"selected_group": 0,
	"settings":
	{
		"lsp_show_inlay_hints": false
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 343.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
